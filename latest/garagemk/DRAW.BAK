#include"draw.h"

void Set_Video_Mode(int mode) //设置显示模式的函数
 {
	 union REGS inregs ,outregs; //定义输入和返回寄存器
	 inregs.h.ah=0; //ah 存放功能号0h 表示进入视频模式设定
     inregs.h.al=(unsigned char) mode ;    //al存放要设定的视频模式
	 int86(0x10,&inregs,&outregs);     //通过10h 中断设定显示模式
 }
//当函数被设定为 VGA256时，屏幕将函数设置为图形模式，当被设定为TEXT_MODE时，回到最初的文本模式

void Plot(int x, int y, char color) /*画点函数*/
{    
     unsigned char far * video_buffer=(char far *)0xA0000000L;
     video_buffer[(y<<8)+(y<<6)+x]=color;
}

int Get_Plot(int x,int y)             /*取点的颜色*/
{ 
    int color;
    unsigned char far * video_buffer=(char far *)0xA0000000L;
    color=video_buffer[(y<<8)+(y<<6)+x];
    return color;
}

void line(int x0,int y0,int x1,int y1,char color)     /*画任意线的函数*/
{   unsigned char far * video_buffer=(char far *)0xA0000000L;
	int dx,dy,x_inc,y_inc,error=0,index;
    unsigned char far *vb_start=video_buffer; //设定起始显存位置
	vb_start=vb_start+((unsigned int )y0<<6)+((unsigned int) y0<<8)+(unsigned int) x0;//以下获得斜线x,y方向上的偏移，同时明确各自偏移方向
	dx=x1-x0;
    dy=y1-y0;
    if(dx>=0) x_inc=1;
    else {x_inc=-1;
		dx=-dx;
         }
    if(dy>=0) y_inc=320;
    else{ y_inc=-320;
         dy=-dy;
    }
    if(dx>dy)
    { //以下如果x长于y的画点循环方法
        for(index=0;index<=dx;index++)
        { *vb_start=color;//设定点的颜色
            error+=dy;
            if(error>dx){//每循环dx/dy次，才满足此条件
                error-=dx;
                vb_start+=y_inc;//y方向增加单位增量，画点
            }
            vb_start+=x_inc;//x方向增加单位增量，画点

        }
    }
    else{//以下如果y长于x的画点循环方法
          for(index=0;index<=dy;index++)
        {
        *vb_start=color;
        error+=dx;
         if(error>0)
        {
            error-=dy;
            vb_start+=x_inc;
        }vb_start+=y_inc;
      
        }      
    }
}

void hline(int x1,int x2,int y,char color) /*画水平线*/
{
    int i;
    for(i=x1;i<=x2;i++)
    {
        Plot(i,y,color);
    }
}
void Rectangle(int x1,int y1,int x2,int y2,char color)
{   
    line(x1,y1,x2,y1,color);
    line(x1,y1,x1,y2,color);
    line(x2,y1,x2,y2,color);
    line(x1,y2,x2,y2,color);
}

void fill_Rectangle(int x1,int y1,int x2,int y2,char color)
{ int i;
  for(i=y1;i<=y2;i++)
  {
      hline(x1,x2,i,color);
  }
}

void BPlot(int x,int y,char color)  //加粗的点
{   unsigned char far * video_buffer=(char far *)0xA0000000L;
video_buffer[((y<<8)+(y<<6))+x]=color;
video_buffer[((y<<8)+(y<<6))+x-1]=color;
video_buffer[((y<<8)+(y<<6))+x-320]=color;
video_buffer[((y<<8)+(y<<6))+x-321]=color;
}

/*void Create_Tables()
{
int index;
for(index=0;index<=360;index++)
{
cos_look[index]=(float)cos((double)(index*3.14159/180));
sin_look[index]=(float)sin((double)(index*3.14159/180));
}
}
void Circle(int x,int y,int r,char  color)  //画圆
{
	int x0,y0,x1,y1,index;
	x0=y0=r;
	for(index=0;index<=360;index++)
	{
		x1=x0*cos_look[index]-y0*sin_look[index];
		y1=x0*sin_look[index]+y0*cos_look[index];
		Plot(x+x1,y+y1,color);
	}

}

void BCircle(int x,int y,int r,char color)   //加粗的圆
{
	int x0,y0,x1,y1,index;
	x0=y0=r;
	for(index=0;index<=360;index++)
	{
		x1=x0*cos_look[index]-y0*sin_look[index];
		y1=x0*sin_look[index]+y0*cos_look[index];
		Plot(x+x1,y+y1,color);
		Plot(x+x1-1,y+y1,color);
		Plot(x+x1,y+y1-1,color);
		Plot(x+x1+1,y+y1,color);
		Plot(x+x1,y+y1+1,color);
		Plot(x+x1+1,y+y1,color);
		Plot(x+x1-1,y+y1-1,color);
		Plot(x+x1+1,y+y1-1,color);
		Plot(x+x1+1,y+y1+1,color);
		Plot(x+x1-1,y+y1+1,color);
	}

}
void fill_Circle(int x,int y,int r,char color)
{
	int index;
	for(index=r;index>0;index--)
	{
		BCircle(x,y,index,color);
	}
}
*/
void Fill_Screen(int value)    //设置背景色
{unsigned char far *video_buffer=(char far *)0xA0000000L;
_fmemset(video_buffer,(char)value,SCREEN_WIDTH*SCREEN_HEIGHT+1);
}

void Fill_Screen_Size(int value,int x0,int y0,int x1,int y1)
{unsigned char far *video_buffer=(char far *)0xA0000000L;
int x,y;
long i=0,height,width;
height=y1-y0+1;
width=x1-x0+1;
x=x0;
while(i<height*width)
{
	y=y0+i/width;
	i=i+width;
	_fmemset(video_buffer+x+y*SCREEN_WIDTH,(char)value,width);
}
}

void Plot_Xor (int x,int y,char color)   //异或点
{
unsigned char far *video_buffer=(char far *)0xA0000000L;
int color_screen;
color_screen=Get_Plot(x,y);
video_buffer[((y<<8)+(y<<6))+x]=color^color_screen;
}

void hline_Xor(int x1,int x2,int y,char color) //异或水平线
{
    int i;
    for(i=x1;i<=x2;i++)
    {
        Plot_Xor(i,y,color);
    }
}

void vline_Xor(int x,int y1,int y2,char color) //异或竖直线
{
    int i;
	for(i=y1;i<=y2;i++)
    { Plot_Xor(x,i,color);

    }
}
void Rectangle_Xor(int x1,int y1,int x2,int y2,char color)
{
	vline_Xor(x1,y1,y2,color);
	vline_Xor(x2,y1,y2,color);
	hline_Xor(x1+1,x2-1,y1,color);
	hline_Xor(x1+1,x2-1,y2,color);
}
void fill_Rectangle_Xor(int x1,int y1,int x2,int y2,char color)
{ int i;
  for(i=y1;i<=y2;i++)
  {
      hline_Xor(x1,x2,i,color);
  }
}

void Set_Palette_Register(int index,RGB_color_ptr color)        //操作调色板
{
outp(PALETTE_MASK,0xff);
outp(PALETTE_REGISTER_WR,index);
outp(PALETTE_DATA,color->red);
outp(PALETTE_DATA,color->green);
outp(PALETTE_DATA,color->blue);
}
void PCX_Init(pcx_picture_ptr image)                           //初始化pcx文件内存空间
{unsigned int a=(unsigned int)(SCREEN_WIDTH1 * SCREEN_HEIGHT1 + 1);
// this function allocates the buffer region needed to load a pcx file
if((image->buffer = (char far *)malloc(a))==NULL)
{
   printf("\ncouldn't allocate screen buffer");
 exit(1);
 }
}

void PCX_Delete(pcx_picture_ptr image)                //删除为pcx申请的内存
{
// this function de-allocates the buffer region used for the pcx file load

farfree(image->buffer);

} // end PCX_Delete

void PCX_Load(char *filename, pcx_picture_ptr image,int enable_palette)    //从pcx图像内存读取子画面到子画面内存
{
FILE *fp;
int num_bytes,index;
unsigned int count;
unsigned char data;
char far *temp_buffer;

// open the file

fp = fopen(filename,"rb");

// load the header

temp_buffer = (char far *)image;

for (index=0; index<128; index++)
    {
    temp_buffer[index] = getc(fp);
    } // end for index

// load the data and decompress into buffer
count=0;


while(count<=(unsigned int)SCREEN_WIDTH * SCREEN_HEIGHT)
	 {
	 // get the first piece of data

	 data = getc(fp);

	 // is this a rle?

	 if (data>=192 && data<=255)
	{
        // how many bytes in run?

        num_bytes = data-192;

	// get the actual data for the run

        data  = getc(fp);

		// replicate data in buffer num_bytes times

        while(num_bytes-->0)
             {
             image->buffer[count++] = data;

             } // end while

        } // end if rle
     else
	{
        // actual data, just copy it into buffer at next location

        image->buffer[count++] = data;

        } // end else not rle

     } // end while

// move to end of file then back up 768 bytes i.e. to begining of palette

fseek(fp,-768L,SEEK_END);

// load the pallete into the palette

for (index=0; index<256; index++)
    {
    // get the red component

    image->palette[index].red   = (getc(fp) >> 2);

    // get the green component

    image->palette[index].green = (getc(fp) >> 2);

    // get the blue component

    image->palette[index].blue  = (getc(fp) >> 2);

    } // end for index

fclose(fp);

// change the palette to newly loaded palette if commanded to do so

if (enable_palette)
   {

   for (index=0; index<256; index++)
       {

       Set_Palette_Register(index,(RGB_color_ptr)&image->palette[index]);

       } // end for index

   } // end if change palette

} // end PCX_Load
void PCX_Load_Screen(char *filename,int enable_palette) //将pcx文件存入内存
{
unsigned char far *video_buffer=(char far *)0xA0000000L;
FILE *fp;
int num_bytes,index;
unsigned int count;
unsigned char data;
RGB_color palette[256];
// open the file


fp = fopen(filename,"rb");


fseek(fp,128L,SEEK_SET);
// load the data and decompress into buffer
count=0;


while(count<=(unsigned int)SCREEN_WIDTH * SCREEN_HEIGHT)
	 {
	 // get the first piece of data

	 data = getc(fp);

	 // is this a rle?

	 if (data>=192 && data<=255)
	{
	// how many bytes in run?

        num_bytes = data-192;

	// get the actual data for the run

	data  = getc(fp);

		// replicate data in buffer num_bytes times

        while(num_bytes-->0)
	     {
//             image->buffer[count++] = data;
  video_buffer[count++]=data;
	     } // end while

	} // end if rle
     else
	{
	// actual data, just copy it into buffer at next location

	//image->buffer[count++] = data;
	  video_buffer[count++]=data;
	} // end else not rle

     } // end while
for (index=0; index<256; index++)
    {
    // get the red component

    palette[index].red   = (getc(fp) >> 2);

    // get the green component

    palette[index].green = (getc(fp) >> 2);

    // get the blue component

    palette[index].blue  = (getc(fp) >> 2);

    } // end for index

fclose(fp);

// change the palette to newly loaded palette if commanded to do so

if (enable_palette)
   {

   for (index=0; index<256; index++)
       {

       Set_Palette_Register(index,(RGB_color_ptr)&palette[index]);

       } // end for index

   } // end if change palette

} // end PCX_Load


void Sprite_Init(sprite_ptr sprite,int x,int y,int ac,int as,int mc,int ms)   //子画面的初始化
{
// this function initializes a sprite with the sent data

int index;

sprite->x            = x;//初始化子画面的横坐标
sprite->y            = y;//初始化子画面纵坐标
sprite->x_old        = x;//初始化子画面原来的横坐标
sprite->y_old        = y; //初始化子画面原来的纵坐标
sprite->width        = SPRITE_WIDTH; //初始化子画面宽度
sprite->height       = SPRITE_HEIGHT;//初始化子画面高度
sprite->anim_clock   = ac;
sprite->anim_speed   = as;
sprite->motion_clock = mc;
sprite->motion_speed = ms;
sprite->curr_frame   = 0;
sprite->state        = PARK_W;
sprite->num_frames   = 0;//初始化子画面数量
sprite->background   = (char far *)malloc(SPRITE_WIDTH * SPRITE_HEIGHT+1);

// set all bitmap pointers to null

for (index=0; index<MAX_SPRITE_FRAMES; index++)  //初始化子画面图像指针指向空
    sprite->frames[index] = NULL;

} // end Sprite_Init

void PCX_Grab_Bitmap(pcx_picture_ptr image, sprite_ptr sprite,int sprite_frame,int grab_x, int grab_y)     //从屏幕读取子画面

{
int x_off,y_off, x,y, index;
char far *sprite_data;

// first allocate the memory for the sprite in the sprite structure

sprite->frames[sprite_frame] = (char far *)malloc(SPRITE_WIDTH * SPRITE_HEIGHT);

// create an alias to the sprite frame for ease of access

sprite_data = sprite->frames[sprite_frame];

// now load the sprite data into the sprite frame array from the pcx picture

// we need to find which bitmap to scan, remember the pcx picture is really a
// 12x8 matrix of bitmaps where each bitmap is 24x24 pixels. note:0,0 is upper
// left bitmap and 11,7 is the lower right bitmap.

x_off = (SPRITE_WIDTH) * grab_x;
y_off = (SPRITE_HEIGHT) * grab_y ;

// compute starting y address

y_off = y_off * 320;

for (y=0; y<SPRITE_HEIGHT; y++)
    {

    for (x=0; x<SPRITE_WIDTH; x++)
	{

	// get the next byte of current row and place into next position in
	// sprite frame data buffer

	sprite_data[y*SPRITE_WIDTH + x] = image->buffer[y_off + x_off + x];

	} // end for x

	// move to next line of picture buffer

	y_off+=320;

    } // end for y

// increment number of frames

sprite->num_frames++;

// done!, let's bail!

} // end PCX_Grap_Bitmap


void Draw_Sprite(sprite_ptr sprite)                            //显示子画面
{
 unsigned char far *video_buffer=(char far *)0xA0000000L;
 // this function draws a sprite on the screen row by row very quickly
 // note the use of shifting to implement multplication

char far *work_sprite;
int work_offset=0,offset,x,y;
//unsigned char data;

// alias a pointer to sprite for ease of access

work_sprite = sprite->frames[sprite->curr_frame];

// compute offset of sprite in video buffer

offset = ((sprite->y) << 8) + ((sprite->y) << 6) + sprite->x;

for (y=0; y<SPRITE_HEIGHT; y++)
    {
    // copy the next row into the screen buffer using memcpy for speed

    for (x=0; x<SPRITE_WIDTH; x++)
	{

	// test for transparent pixel i.e. 0, if not transparent then draw
      if(work_sprite[work_offset+x])

	 //data==(unsigned char)work_sprite[work_offset+x];
// if(data)
//	     video_buffer[offset+x] =data;
     video_buffer[offset+x]=work_sprite[work_offset+x];
	} // end for x

    // move to next line in video buffer and in sprite bitmap buffer

	offset      += SCREEN_WIDTH;
	work_offset += SPRITE_WIDTH;

    } // end for y

} // end Draw_Sprite

void Behind_Sprite_Size(sprite_ptr sprite,int height,int width)                 //取图片背后内容
{
unsigned char far *video_buffer=(char far *)0xA0000000L;
// this function scans the background behind a sprite so that when the sprite
// is draw, the background isnn'y obliterated

char far *work_back;
int work_offset=0,offset,y;

// alias a pointer to sprite background for ease of access

work_back = sprite->background;

// compute offset of background in video buffer

offset = (sprite->y << 8) + (sprite->y << 6) + sprite->x;

for (y=0; y<height; y++)
    {
    // copy the next row out off screen buffer into sprite background buffer

    _fmemmove((void far *)&work_back[work_offset],
	     (void far *)&video_buffer[offset],
	     width);

    // move to next line in video buffer and in sprite background buffer

    offset      += SCREEN_WIDTH;
    work_offset += width;

    } // end for y

} // end Behind_Sprite

void Draw_Sprite_Size(sprite_ptr sprite,int height,int width)       //显示小图片于鼠标位置
{
unsigned char far *video_buffer=(char far *)0xA0000000L;
// this function draws a sprite on the screen row by row very quickly
// note the use of shifting to implement multplication

char far *work_sprite;
int work_offset=0,offset,x,y;
//unsigned char data;

// alias a pointer to sprite for ease of access

work_sprite = sprite->frames[sprite->curr_frame];

// compute offset of sprite in video buffer

offset = ((sprite->y) << 8) + ((sprite->y) << 6) + sprite->x;

for (y=0; y<height; y++)
    {
    // copy the next row into the screen buffer using memcpy for speed

    for (x=0; x<width; x++)
	{

	// test for transparent pixel i.e. 0, if not transparent then draw
      if(work_sprite[work_offset+x])

	 //data==(unsigned char)work_sprite[work_offset+x];
// if(data)
//	     video_buffer[offset+x] =data;
     video_buffer[offset+x]=work_sprite[work_offset+x];
	} // end for x

    // move to next line in video buffer and in sprite bitmap buffer

    offset      += SCREEN_WIDTH;
    work_offset += width;

    } // end for y
} // end Draw_Sprite

void Behind_Sprite(sprite_ptr sprite)                 //取子画面背后内容
{
unsigned char far *video_buffer=(char far *)0xA0000000L;
// this function scans the background behind a sprite so that when the sprite
// is draw, the background isnn'y obliterated

char far *work_back;
int work_offset=0,offset,y;

// alias a pointer to sprite background for ease of access

work_back = sprite->background;

// compute offset of background in video buffer

offset = (sprite->y << 8) + (sprite->y << 6) + sprite->x;

for (y=0; y<SPRITE_HEIGHT; y++)
    {
    // copy the next row out off screen buffer into sprite background buffer

    _fmemmove((void far *)&work_back[work_offset],
	     (void far *)&video_buffer[offset],
		 SPRITE_WIDTH);

    // move to next line in video buffer and in sprite background buffer

	offset      += SCREEN_WIDTH;
	work_offset += SPRITE_WIDTH;

    } // end for y

} // end Behind_Sprite


void Erase_Sprite(sprite_ptr sprite)                 //显示子画面后面的内容
{unsigned char far *video_buffer=(char far *)0xA0000000L;
// replace the background that was behind the sprite

// this function replaces the background that was saved from where a sprite
// was going to be placed

char far *work_back;
int work_offset=0,offset,y;

// alias a pointer to sprite background for ease of access

work_back = sprite->background;

// compute offset of background in video buffer

offset = (sprite->y << 8) + (sprite->y << 6) + sprite->x;

for (y=0; y<SPRITE_HEIGHT; y++)
    {
    // copy the next row out off screen buffer into sprite background buffer

    _fmemmove((void far *)&video_buffer[offset],
	     (void far *)&work_back[work_offset],
	     SPRITE_WIDTH);

    // move to next line in video buffer and in sprite background buffer

	offset      += SCREEN_WIDTH;
	work_offset += SPRITE_WIDTH;

    } // end for y


} // end Erase_Sprite

void Erase_Sprite_Size(sprite_ptr sprite,int height,int width)          //显示小图片背后背景内容
{
    
unsigned char far *video_buffer=(char far *)0xA0000000L;
// replace the background that was behind the sprite

// this function replaces the background that was saved from where a sprite
// was going to be placed

char far *work_back;
int work_offset=0,offset,y;

// alias a pointer to sprite background for ease of access

work_back = sprite->background;

// compute offset of background in video buffer

offset = (sprite->y << 8) + (sprite->y << 6) + sprite->x;

for (y=0; y<height; y++)
    {
    // copy the next row out off screen buffer into sprite background buffer

    _fmemmove((void far *)&video_buffer[offset],
	     (void far *)&work_back[work_offset],
	     width);

    // move to next line in video buffer and in sprite background buffer

    offset      += SCREEN_WIDTH;
    work_offset += width;

    } // end for y


} // end Erase_Sprite

void Sprite_Init_Size(sprite_ptr sprite,int x,int y,int ac,int as,int mc,int ms,int height,int width,int frame)     //初始化小图片
{
// this function initializes a sprite with the sent data

int index;

sprite->x            = x;
sprite->y            = y;
sprite->x_old        = x;
sprite->y_old        = y;
sprite->width        = width;
sprite->height       = height;
sprite->anim_clock   = ac;
sprite->anim_speed   = as;
sprite->motion_clock = mc;
sprite->motion_speed = ms;
sprite->curr_frame   = 0;
sprite->state        = 0;
sprite->num_frames   = 0;
sprite->background   = (char far *)malloc(width * height+1);

// set all bitmap pointers to null

for (index=0; index<frame; index++)
    sprite->frames[index] = NULL;

} // end Sprite_Init

void PCX_Grab_Bitmap_Size_Screen(pcx_picture_ptr image,sprite_ptr sprite,int sprite_frame,int grab_x, int grab_y,int height,int width)
{unsigned char far *video_buffer=(char far *)0xA0000000L;
int x_off,y_off, x,y, index;
char far *sprite_data;

// first allocate the memory for the sprite in the sprite structure

sprite->frames[sprite_frame] = (char far *)malloc(width * height);

// create an alias to the sprite frame for ease of access

sprite_data = sprite->frames[sprite_frame];

// now load the sprite data into the sprite frame array from the pcx picture

// we need to find which bitmap to scan, remember the pcx picture is really a
// 12x8 matrix of bitmaps where each bitmap is 24x24 pixels. note:0,0 is upper
// left bitmap and 11,7 is the lower right bitmap.

x_off = (width) * grab_x;
y_off = (height) * grab_y ;

// compute starting y address

y_off = y_off * 320;

for (y=0; y<height; y++)
    {

    for (x=0; x<width; x++)
	{

	// get the next byte of current row and place into next position in
	// sprite frame data buffer

	sprite_data[y*width + x] = video_buffer[y_off + x_off + x+1];

	} // end for x

	// move to next line of picture buffer

	y_off+=320;

    } // end for y

// increment number of frames

sprite->num_frames++;

// done!, let's bail!

} // end PCX_Grap_Bitmap

void PCX_Load1(char *filename, pcx_picture_ptr image,int enable_palette)
{unsigned char far *video_buffer=(char far *)0xA0000000L;
FILE *fp;
int num_bytes,index;
unsigned int count;
unsigned char data;
char far *temp_buffer;

// open the file

fp = fopen(filename,"rb");

// load the header

temp_buffer = (char far *)image;

for (index=0; index<128; index++)
    {
    temp_buffer[index] = getc(fp);
    } // end for index

// load the data and decompress into buffer
count=0;


while(count<=(unsigned int)SCREEN_WIDTH * SCREEN_HEIGHT)
	 {
	 // get the first piece of data

	 data = getc(fp);

	 // is this a rle?

     if (data>=192 && data<=255)
	{
	// how many bytes in run?

        num_bytes = data-192;

	// get the actual data for the run

	data  = getc(fp);

		// replicate data in buffer num_bytes times

        while(num_bytes-->0)
             {
//             image->buffer[count++] = data;
  video_buffer[count++]=data;
	     } // end while

	} // end if rle
     else
	{
	// actual data, just copy it into buffer at next location

	//image->buffer[count++] = data;
	  video_buffer[count++]=data;
	} // end else not rle

     } // end while

// move to end of file then back up 768 bytes i.e. to begining of palette

fseek(fp,-768L,SEEK_END);

// load the pallete into the palette

for (index=0; index<256; index++)
    {
    // get the red component

    image->palette[index].red   = (getc(fp) >> 2);

    // get the green component

    image->palette[index].green = (getc(fp) >> 2);

    // get the blue component

    image->palette[index].blue  = (getc(fp) >> 2);

    } // end for index

fclose(fp);

// change the palette to newly loaded palette if commanded to do so

if (enable_palette)
   {

   for (index=0; index<256; index++)
       {

       Set_Palette_Register(index,(RGB_color_ptr)&image->palette[index]);

       } // end for index

   } // end if change palette

} // end PCX_Load

void Sprite_Delete_Size(sprite_ptr sprite,int frame)
{
// this function deletes all the memory associated with a sprire

int index;

farfree(sprite->background);

// now de-allocate all the animation frames

for (index=0; index<frame; index++)
    farfree(sprite->frames[index]);

} // end Sprite_Delete


void Sprite_Delete(sprite_ptr sprite)
{
// this function deletes all the memory associated with a sprire

int index;

farfree(sprite->background);

// now de-allocate all the animation frames

for (index=0; index<MAX_SPRITE_FRAMES; index++)
    farfree(sprite->frames[index]);
free(sprite);
} // end Sprite_Delete

//填充就用循环画线或者点
						  


